# Система оновлення бази даних аніме: Огляд реалізації

Цей документ надає огляд реалізації покращеної системи оновлення бази даних аніме. Система розроблена для ефективного керування масштабним каталогом аніме, дотримання лімітів API та пріоритизації найважливішого контенту.

## Основні компоненти

### 1. Поля відстеження оновлень

До моделі `Anime` додані нові поля для підтримки пріоритизації та відстеження:
- `update_priority`: Числове значення (1-10), що вказує пріоритет оновлення
- `last_full_update`, `last_metadata_update`, `last_episodes_update`, `last_images_update`: Часові мітки для різних типів оновлень
- `update_failures`: Лічильник невдалих спроб оновлення
- `next_update_scheduled`: Коли аніме має бути оновлене наступного разу

### 2. Модель стратегії оновлення

Нова модель для визначення стратегій оновлення:
- Конфігурація лімітів API
- Налаштування частоти оновлень для різних типів аніме
- Вагові коефіцієнти пріоритетів для різних категорій аніме
- Налаштування пакетної обробки

### 3. Сервіс обмеження швидкості API

Потужний сервіс, який:
- Відстежує статистику використання API
- Реалізує адаптивне очікування між запитами
- Застосовує обмеження швидкості з експоненціальним відступом
- Декорує API-запити для автоматичного застосування обмежень

### 4. Планувальник оновлень на основі пріоритетів

Сервіс, який:
- Обчислює оцінки пріоритету на основі характеристик аніме
- Планує оновлення з відповідними інтервалами
- Вибирає оптимальних кандидатів для оновлень
- Записує спроби оновлення та коригує майбутнє планування

### 5. Моніторинг та аналітика

Інтерфейси адміністратора для:
- Статистики використання API та моніторингу лімітів
- Відстеження успішності/невдалості оновлень
- Аналізу розподілу пріоритетів
- Керування розкладом оновлень

## Ключові функції

### Адаптивна пріоритизація оновлень

Система обчислює пріоритети оновлень на основі:
- Статусу контенту (поточні аніме отримують вищий пріоритет)
- Давності (нещодавно оновлений контент отримує нижчий пріоритет)
- Історії невдач (повторні невдачі знижують пріоритет для запобігання марнування API)
- Повноти контенту (аніме без скріншотів/епізодів отримують вищий пріоритет)

Формула пріоритету в `calculate_update_priority()`:
```python
def calculate_update_priority(self):
    base_priority = 5  # Стандартний середній пріоритет
    
    # Онгоінги отримують вищий пріоритет
    if self.status == 'ongoing':
        base_priority += 3
    
    # Нещодавно оновлені аніме отримують нижчий пріоритет
    if self.last_full_update:
        days_since_update = (timezone.now() - self.last_full_update).days
        if days_since_update < 7:
            base_priority -= 2  # Значно знижуємо пріоритет для дуже недавніх оновлень
        elif days_since_update < 30:
            base_priority -= 1  # Помірно знижуємо для оновлень до місяця
    
    # Нові аніме (без оновлень) отримують вищий пріоритет
    if not self.last_full_update:
        base_priority += 2
    
    # Аніме з невдачами отримують нижчий пріоритет для запобігання марнуванню API
    if self.update_failures > 3:
        base_priority -= 2
    
    # Обмежуємо значення між 1-10
    return max(1, min(10, base_priority))
```

### Розумне планування оновлень

Оновлення плануються на основі:
- Статусу аніме (онгоінги - щодня, анонсовані - щотижня, завершені - щомісяця)
- Пріоритету оновлення (вищий пріоритет = частіші оновлення)
- Історії попередніх невдач (експоненціальний відступ)

Логіка планування:
```python
def schedule_next_update(self):
    base_days = 30  # За замовчуванням: раз на місяць
    
    # Коригуємо на основі статусу
    if self.status == 'ongoing':
        base_days = 1  # Щодня для онгоінгів
    elif self.status == 'announced':
        base_days = 7  # Щотижня для анонсованих
    
    # Коригуємо для пріоритету (вищий пріоритет = частіші оновлення)
    priority_factor = (11 - self.update_priority) / 5  # 10->0.2, 5->1.2, 1->2
    days = int(base_days * priority_factor)
    
    # Встановлюємо час наступного оновлення
    self.next_update_scheduled = timezone.now() + datetime.timedelta(days=max(1, days))
```

### Диференціальні оновлення

Система підтримує різні типи оновлень:
- **Повні оновлення**: Повне оновлення всіх даних аніме
- **Оновлення метаданих**: Оновлення тільки базової інформації
- **Оновлення епізодів**: Оновлення даних епізодів для поточних серіалів
- **Оновлення зображень**: Оновлення скріншотів та візуального контенту

Це дозволяє ефективніше використовувати ресурси, оновлюючи тільки те, що потрібно.

### Обмеження швидкості API

Система включає складне обмеження швидкості:
- Відстежує щоденні та щохвилинні показники запитів
- Реалізує адаптивне очікування між запитами
- Використовує експоненціальний відступ при наближенні до лімітів
- Додає випадкові варіації для запобігання синхронізованим запитам

Обмеження швидкості реалізовано як декоратор:
```python
@rate_limited(api_name="Jikan")
def fetch_top_anime(self, page=1, limit=25, retries=3, delay=2):
    # Реалізація методу...
```

### Комплексне логування

Усі API-запити та операції оновлення логуються:
- `APIRequestLog`: Детальні логи всіх API-викликів
- `UpdateLog`: Запис усіх операцій оновлення аніме
- Агрегація статистики в інтерфейсі адміністратора

## Удосконалення адміністративного інтерфейсу

### 1. Панель статистики використання API
- Моніторинг використання API в реальному часі
- Показники успішності/невдалості
- Статус обмежень швидкості
- Історія запитів
- Візуалізація використання API у часі

### 2. Панель статистики оновлень
- Показники успішності оновлень
- Розподіл за типами оновлень
- Нещодавно оновлені аніме
- Розклад майбутніх оновлень
- Аніме, що потребують негайного оновлення
- Графічне представлення активності оновлень

### 3. Інструменти керування оновленнями
- Кнопки для запуску різних типів оновлень одним кліком
- Перерахунок пріоритетів
- Керування розкладом
- Опції для масового оновлення

## Алгоритм адаптивного очікування

Система використовує розумний алгоритм очікування між API-запитами, який адаптується до поточного використання:

```python
def adaptive_wait(api_name):
    stats = APIRateLimiter.get_api_stats(api_name)
    strategy = UpdateStrategy.objects.filter(is_active=True).first()
    
    # Базовий час очікування
    base_wait = 60 / strategy.api_requests_per_minute
    
    # Додаємо випадкові варіації для запобігання синхронізації
    jitter = random.uniform(-0.3, 0.3) * base_wait
    
    # Обчислюємо відсоток використання
    daily_usage_percent = (stats.daily_count / strategy.api_requests_per_day) * 100
    
    # Експоненціальний відступ при наближенні до лімітів
    if daily_usage_percent > 90:
        # Дуже близько до ліміту, бути дуже обережним
        backoff_factor = 5.0
    elif daily_usage_percent > 75:
        backoff_factor = 2.0
    elif daily_usage_percent > 50:
        backoff_factor = 1.5
    else:
        backoff_factor = 1.0
    
    wait_time = (base_wait * backoff_factor) + jitter
    return max(0.5, wait_time)
```

## Як користуватися

### Базове використання

1. **Перегляд статистики оновлень**: Перейдіть до "API статистика" або "Статистика оновлень" з адмін-панелі аніме
2. **Запуск розумних оновлень**: Використовуйте кнопку "Оновити пріоритетні аніме" для оновлення контенту з найвищим пріоритетом
3. **Керування правилами оновлень**: Налаштуйте стратегії оновлення через інтерфейс "Стратегія оновлення"

### Розширене використання

1. **Налаштування стратегії оновлення**: Створіть нову стратегію з різними лімітами API та ваговими коефіцієнтами пріоритетів
2. **Планування регулярних оновлень**: Налаштуйте завдання Celery beat, які викликають `update_anime_by_priority_task` через регулярні інтервали
3. **Діагностика проблем з API**: Використовуйте панель статистики використання API для усунення проблем з обмеженнями швидкості
4. **Налаштування типів оновлень**: Використовуйте різні типи оновлень (метадані, епізоди, зображення) для різних вимог

## Оптимізаційні техніки

1. **Селективне оновлення атрибутів**: 
   - При оновленні даних використовуємо `update_fields` для зміни лише необхідних полів
   - Це зменшує навантаження на базу даних та запобігає конфліктам між паралельними оновленнями

2. **Попереднє завантаження зв'язаних даних**:
   - Використовуємо `select_related` та `prefetch_related` для оптимізації запитів
   - Зменшує кількість звернень до бази даних при роботі зі складними об'єктами

3. **Пакетна обробка**:
   - Обробка аніме пакетами замість окремих запитів
   - Дозволяє ефективніше використовувати ресурси системи

4. **Інкрементні оновлення**:
   - Оновлюємо тільки змінені дані замість повної заміни об'єктів
   - Економить трафік API та час обробки

## Майбутні вдосконалення

1. **Пріоритизація на основі машинного навчання**: Навчити модель передбачати, які аніме найімовірніше будуть переглянуті/оновлені
2. **Відстеження інтересів користувачів**: Врахування активності користувачів для пріоритизації популярного контенту
3. **Резервні джерела даних**: Впровадження автоматичного переходу між різними джерелами даних у разі проблем
4. **Розподілене навантаження**: Розподіл завдань оновлення між кількома працівниками для підвищення пропускної здатності
5. **Розумна черга оновлень**: Динамічне коригування черги оновлень на основі поточного навантаження та доступності API
6. **Інтеграція з зовнішніми планувальниками**: Налаштування взаємодії з системами оркестрації контейнерів для масштабування

## Моніторинг продуктивності

Система включає комплексні інструменти моніторингу для відстеження ефективності оновлень:

1. **Метрики успішності**: Відстеження відсотка успішних оновлень по типам і джерелам
2. **Часові показники**: Аналіз часу, необхідного для різних типів оновлень
3. **Використання API**: Візуалізація використання API з попередженнями про наближення до лімітів
4. **Ефективність планувальника**: Оцінка того, наскільки добре система обирає пріоритети для оновлень

## Висновок

Реалізована система оновлення аніме представляє комплексне рішення для управління великими колекціями даних з зовнішніх API. Вона забезпечує ефективне використання обмежених ресурсів API, пріоритизацію контенту на основі його важливості та детальний моніторинг процесу оновлення. Побудована на принципах розумного планування, адаптивних алгоритмів та диференційних оновлень, система забезпечує актуальність даних навіть при великих обсягах контенту.
